;; -*- mode: wat -*-

(type $String (array (mut i8)))
;; (type $Array<String> (array (mut (ref $String))))

(func $strlen (param $string i32) (result i32)
  (locals i32 $ptr)
  (local.set $ptr $string)
  (loop $loop
    (if (i32.ne (i32.load8_u $ptr) 0)
      (then
        (local.set $ptr (i32.add $ptr 1))
        (br $loop))))
  (i32.sub $ptr $string))

(func $strcmp (param $s0 i32) (param $s1 i32) (result i32)
  (locals i32 $c0 $c1)
  (loop $loop
    (if
      (i32.eq
        (local.tee $c0 (i32.load8_u $s0))
        (local.tee $c1 (i32.load8_u $s1)))
      (then
        (if $c0
          (then
            (local.set $s0 (i32.add $s0 1))
            (local.set $s1 (i32.add $s1 1))
            (br $loop)))
        (return 0))))
  (i32.sub $c0 $c1))

(func $memcmp (param $p0 i32) (param $p1 i32) (param $len i32) (result i32)
  (locals i32 $c0 $c1)
  (loop $loop
    (if (i32.eqz $len)
      (then (return 0)))
    (if
      (i32.eq
        (local.tee $c0 (i32.load8_u $p0))
        (local.tee $c1 (i32.load8_u $p1)))
      (then
        (local.set $p0 (i32.add $p0 1))
        (local.set $p1 (i32.add $p1 1))
        (local.set $len (i32.sub $len 1))
        (br $loop))))
  (select 1 -1
    (i32.lt_u $c0 $c1)))

;; (func $strdup (param $s i32) (result i32)
;;   (locals i32 $len $buf)
;;   (local.set $len (call $strlen $s))
;;   (local.set $buf (call $malloc (i32.add $len 1)))
;;   (memory.copy $buf $s $len)
;;   $buf)

(func $strrchr (param $str i32) (param $c i32) (result i32)
  (locals i32 $ptr)
  (local.set $ptr (i32.add $str (call $strlen $str)))
  (loop $loop
    (if (i32.lt_u $ptr $str)
      (then (return 0)))
    (if (i32.ne (i32.load8_u $ptr) $c)
      (then
        (local.set $ptr (i32.sub $ptr 1))
        (br $loop))))
  $ptr)

(func $strchr (param $str i32) (param $c i32) (result i32)
  (locals i32 $d)
  (loop $loop
    (if (local.tee $d (i32.load8_u $str))
      (then
        (if (i32.eq $d $c)
          (then (return $str)))
        (local.set $str (i32.add $str 1))
        (br $loop))))
  0)

(func $rPad (param $ch i32) (param $str (ref $String)) (param $n i32) (result (ref $String))
  (if (ge_s (array.len $str) $n)
    (then (return $str)))
  (return_call $rPadAndChop $ch $str $n))

(func $rPadAndChop (param $ch i32) (param $str (ref $String)) (param $n i32) (result (ref $String))
  (locals i32 $len $start $i)
  (locals (ref $String) $result)
  (local.set $len (call $i32.min (array.len $str) $n))
  (local.set $result (array.new $String $ch $n))
  (local.set $start (- $n $len))
  (loop $fill
    (if (lt_u $i $len)
      (then
        (array.set $String $result (+ $start $i)
          (array.get_u $String $str $i))
        (add! $i 1)
        (br $fill))))
  $result)

(func $countChar (param $string i32) (param $targetChar i32) (result i32)
  (locals i32 $count $current)
  (loop $loop
    (if (local.tee $current (i32.load8_u $string))
      (then
        (if (i32.eq $current $targetChar)
          (then (local.set $count (i32.add $count 1))))
        (local.set $string (i32.add $string 1))
        (br $loop))))
  $count)

(func $subString (param $str (ref $String)) (param $start i32) (param $end i32) (result (ref $String))
  (locals (ref $String) $result)
  (locals i32 $n $i)
  (call $assert (bit-and (le_s 0 $start) (le_s $end (array.len $str))))
  (local.set $result (array.new_default $String (local.tee $n (- $end $start))))
  (loop $fill
    (if (lt_u $i $n)
      (then
        (array.set $String $result $i
          (array.get_u $String $str (+ $start $i)))
        (add! $i 1)
        (br $fill))))
  $result)

(func $split.fn
  (param $str (ref $String)) (param $pred (ref $Closure.Base)) (param $allowEmpty i32)
  (result (ref null $list<*>.T))

  (locals i32 $i $end $c)
  (locals (ref null $list<*>.T) $result)

  (local.set $i (local.tee $end (array.len $str)))
  (loop $loop
    (add! $i -1)
    (if (le_s 0 $i)
      (then
        (local.set $c (array.get_u $String $str $i))
        (if (call_closure (param i32) (result i32) $pred $c)
          (then
            (block $skip
              (if (! $allowEmpty)
                (then (br_if $skip (= (+ $i 1) $end))))
              (local.set $result
                (call $list<*>.cons (call $subString $str (+ $i 1) $end) $result)))
            (local.set $end $i)))
        (br $loop))))
  (if (i32.or (!= 0 $allowEmpty) (!= 0 $end))
    (then
      (local.set $result
        (call $list<*>.cons (call $subString $str 0 $end) $result))))
  $result)

(func $split.ws
  (param $str (ref $String)) (param $allowEmpty i32)
  (result (ref null $list<*>.T))

  (call $split.fn $str
    (closure () (param $c i32) (result i32)
      (bit-or (= #\space $c) (= #\newline $c) (= #\tab $c)))
    $allowEmpty))

(func $split
  (param $str (ref $String)) (param $sep i32) (param $allowEmpty i32)
  (result (ref null $list<*>.T))
  (call $split.fn $str
    (closure (($sep i32)) (param $c i32) (result i32)
      (= $sep $c))
    $allowEmpty))

;; Adapted from https://en.cppreference.com/w/cpp/algorithm/rotate.html
(func $memrotate.left (param $first i32) (param $middle i32) (param $last i32)
  (locals i32 $read $write $nextRead)

  (if (i32.eq $first $middle)
    (then (return)))
  (if (i32.eq $middle $last)
    (then (return)))

  (local.set $write $first)
  (local.set $nextRead $first)
  (local.set $read $middle)
  (loop $loop
    (if (i32.eq $write $nextRead)
      (then (local.set $nextRead $read)))
    (call $i8.swap $write $read)
    (local.set $write (i32.add $write 1))
    (local.set $read (i32.add $read 1))
    (br_if $loop (i32.ne $read $last)))
  (return_call $memrotate.left $write $nextRead $last))

(func $parseI32 (param $str (ref $String)) (result i32)
  (locals i32 $result $digit $negative $offset $n)
  (local.set $n (array.len $str))
  (if (= (array.get_u $String $str 0) #\-)
    (then
      (local.set $negative 1)
      (local.set $offset 1)))
  (loop $loop
    (if (lt_u $offset $n)
      (then
        (local.set $digit (- (array.get_u $String $str $offset) #\0))
        (if (lt_u $digit 10)
          (then
            (local.set $result (+ (* $result 10) $digit))
            (add! $offset 1)
            (br $loop))))))
  (if $negative (then (local.set $result (- $result))))
  $result)
